### introduction

#### 1.2 No Longer CPU Bound
* 以前JVM的编译优化不足，程序本身运行就比较慢，所以很少关注IO的影响
* 现在说I/O bound，其实也不是真正的I/O bound，并不是操作系统不能提供足够快的数据传输
* 是操作系统和java的流式I/O配合不协调，操作系统以大块数据传输，而JVM的I/O类趋向处理小片数据
* JVM需要把操作系统传输的大块数据，切割成小片，并且要在各层对象之间拷贝，这才是I/O操作耗时的地方
* NIO做的就是把从操作系统取到的大块数据备份到一个可以直接使用的地方

#### 1.3 Getting to the Good Stuff
* 操作系统供应商在提升I/O性能方面取得的成果，java需要保持跨平台同时能够利用这些成果
* NIO并不能利用所有操作系统的所有优化，但是充分利用了主流操作系统通用的高性能I/O特性

#### 1.4 I/O Concepts
##### 1.4.1 Buffer Handling
* 数据从硬盘读入内存时，进程发出read()系统调用，内核向disk controller发出指令，disk controller通过DMA将数据写入内核buffer，这不需要占用CPU时间，然内核将数据从这个临时buffer拷贝到进程指定的buffer
* regular process存在于用户空间，操作系统存在于内核空间，用户空间的进程没有特权，不能直接访问硬件设备，内核具有和设备通信、管理用户空间的特权
* 所有I/O流都会经过内核空间
* 用户进程读取的数据有可能会缓存或者预读取到内核，这时直接拷贝出来（TODO 到用户空间的内存）；如果没有则进程暂停，等待内核将数据读到（用户空间的）内存
* 由内核空间中转硬盘数据到内存，是因为1. 用户空间不能直接访问硬盘；2.硬盘操作的是固定大小的数据块，用户进程操作的可能是任意大小的数据，或者是跨数据块的数据，中间需要一层中转
###### 1.4.1.1 Scatter/gather
* 操作系统允许进程传入多个buffer，read时将数据块打散到多个buffer，write时将多个buffer的数据聚合一次写入
##### 1.4.2 Virtual Memory
* 虚拟内存有两大好处，1. 多个虚拟内存的地址可能对应同一块物理内存；2. 虚拟内存的空间可以比实际的物理内存大
* 利用第一点，可以实现设备控制器直接把数据读入用户空间，原理是，把用户空间的一个虚拟地址和内核空间的一块空间映射到同一块物理内存，这样DMA填充的数据对内核和用户空间同时可见