### introduction

#### 1.2 No Longer CPU Bound
* 以前JVM的编译优化不足，程序本身运行就比较慢，所以很少关注IO的影响
* 现在说I/O bound，其实也不是真正的I/O bound，并不是操作系统不能提供足够快的数据传输
* 是操作系统和java的流式I/O配合不协调，操作系统以大块数据传输，而JVM的I/O类趋向处理小片数据
* JVM需要把操作系统传输的大块数据，切割成小片，并且要在各层对象之间拷贝，这才是I/O操作耗时的地方
* NIO做的就是把从操作系统取到的大块数据备份到一个可以直接使用的地方

#### 1.3 Getting to the Good Stuff
* 操作系统供应商在提升I/O性能方面取得的成果，java需要保持跨平台同时能够利用这些成果
* NIO并不能利用所有操作系统的所有优化，但是充分利用了主流操作系统通用的高性能I/O特性

#### 1.4 I/O Concepts
##### 1.4.1 Buffer Handling
* 数据从硬盘读入内存时，进程发出read()系统调用，内核向disk controller发出指令，disk controller通过DMA将数据写入内核buffer，这不需要占用CPU时间，然内核将数据从这个临时buffer拷贝到进程指定的buffer
* regular process存在于用户空间，操作系统存在于内核空间，用户空间的进程没有特权，不能直接访问硬件设备，内核具有和设备通信、管理用户空间的特权
* 所有I/O流都会经过内核空间
* 用户进程读取的数据有可能会缓存或者预读取到内核，这时直接拷贝出来（TODO 到用户空间的内存）；如果没有则进程暂停，等待内核将数据读到（用户空间的）内存
* 由内核空间中转硬盘数据到内存，是因为1. 用户空间不能直接访问硬盘；2.硬盘操作的是固定大小的数据块，用户进程操作的可能是任意大小的数据，或者是跨数据块的数据，中间需要一层中转
###### 1.4.1.1 Scatter/gather
* 操作系统允许进程传入多个buffer，read时将数据块打散到多个buffer，write时将多个buffer的数据聚合一次写入
##### 1.4.2 Virtual Memory
* 虚拟内存有两大好处，1. 多个虚拟内存的地址可能对应同一块物理内存；2. 虚拟内存的空间可以比实际的物理内存大
* 利用第一点，可以实现设备控制器直接把数据读入用户空间，原理是，把用户空间的一个虚拟地址和内核空间的一块空间映射到同一块物理内存，这样DMA填充的数据对内核和用户空间同时可见
* 操作系统会把内存划分成page管理，page通常是磁盘扇区的倍数（2的指数倍），比如扇区512byte，page1024/2048/4069byte
* 用户空间操作的buffer也是扇区的倍数
* 虚拟内存和物理内存的page size大小相同
##### 1.4.3 Memory Paging
* 虚拟内存会被换进或换出物理内存，swapping是进程维度的操作，不是page维度的（TODO 是指的一个进程的所有page都会被换进或换出？）
* 被换出的page中的内容存储在磁盘的page area
* page的大小是扇区的倍数，使得内核可以直接向磁盘控制器发送指令，将page写入磁盘，或从磁盘载入page，现代操作系统中磁盘和物理内存的数据I/O操作都是page层面的
* 现代操作系统中有一个Memory Management Unit (MMU).它逻辑上存在于CPU和物理内存之间，会维护虚拟内存和物理内存之间的映射，当CPU指向一个内存位置时MMU来决定是哪个page，当虚拟内存和物理内存的映射关系不存在时（虚拟内存中的的数据不在物理内存中），MMU会告诉CPU一个page fault
* page fault（缺页）会引发中断，用户进程会把CPU控制权交给内核，并带有缺页虚拟地址的信息（TODO 从中可以知道磁盘位置？），内核从磁盘把数据读入物理内存，有可能导致换出另一个page，如果被换出的page内容有变化要把内容拷贝回磁盘
* 如果访问的虚拟内存地址不属于任何一个执行进程，会出现segmentation fault，（请求）进程被kill
* page fault验证完成后，虚拟内存和物理内存重新建立映射，用户进程重新启动，这个过程对用户进程完全透明
* 内核中有复杂的算法，保证分页调度的过程不会特别严重或者抖动，导致影响系统中的其他工作
##### 1.4.4 File I/O
* 文件系统是一种描述磁盘数据的高度抽象，定义了文件名，文件路径，文件属性等
* 页操作是底层操作，如何转换到file I/O， 操作任意大小和位置上的数据？
* 文件系统维护一系列相同大小的数据块，一些数据块存储元数据，一些存储文件数据；文件的元数据描述了文件数据存储在哪些数据块，文件的开始结束，更新时间
* 当用户进程请求文件数据，文件系统定位到数据存储在磁盘的位置，然后从磁盘以扇区为单位把数据读入内存，老的操作系统会直接向磁盘发送指令，现代操作系统通过分页调度的方式完成
* 文件系统也有page的概念，大小一般是内存page的倍数
* 文件系统的I/O操作可以归结为以下步骤（读取步骤）：
    1. 计算请求的数据涉及哪些文件系统page，文件内容及元数据可能存在于多个文件系统page，而且不连续
    1. 内存page为文件系统page分配足够的空间
    1. 内存page与文件page在磁盘上的数据建立映射关系
    1. 分页调度的机制将数据读入内存
    1. 文件系统将数据分解，并抽取请求的文件内容或文件属性
* 文件系统数据也会缓存，不是每次都从磁盘读取，而且也会预读取    
* 写入文件是page被换出的时候内容被同步到磁盘
##### 1.4.4.1 Memory-mapped files
* 传统I/O调用read，write系统调用，需要在内核空间的文件系统page和用户空间的内存之间多次拷贝数据，因为page和buffer之间空间大小不对齐
* 内存映射I/O在用户空间和文件page（内核空间）之间建立虚拟内存映射
    1. 虚拟内存共享物理内存的机制使得用户进程能够直接访问到内存中的文件数据，当数据不在内存中时缺页中断机制会将数据读入内存
    1. 会使用到虚拟内存机制中缓存数据的特点
    1. page为单位的数据使得不需要buffer作为中间转换层    
##### 1.4.4.2 File locking
* 文件加锁的粒度不一定是整个文件，有可能是文件的某一部分，也分为共享锁和排他锁 
* （TODO）File locks are either advisory or mandatory   
##### 1.4.5 Stream I/O
* 流式I/O有两种，阻塞和非阻塞